<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>


  
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><title>jeffWelling/tcd @ GitHub</title>
  

  
  
  <style type="text/css">
body {
  background-color: #000002;
  color: #ffffff;
  margin-top: 1em;
  font-family: "Helvetica,Arial,FreeSans";
}
#container {
  margin: 0 auto;
  width: 700px;
}
h1 {
  font-size: 3.8em;
  color: #eeea71;
  margin-bottom: 3px;
}
h1 .small {
  font-size: 0.4em;
}
h1 a {
  text-decoration: none;
}
h2 {
  font-size: 1.5em;
  color: #eeea71;
}
h3 {
  text-align: center;
  color: #eeea71;
}
a {
  color: #eeea71;
}
.description {
  font-size: 1.2em;
  margin-bottom: 30px;
  margin-top: 30px;
  font-style: italic;
}
.download {
  float: right;
}
pre {
  padding: 15px;
  background: #000000 none repeat scroll 0%;
  color: #ffffff;
}
hr {
  border-style: none none solid;
  border-color: -moz-use-text-color -moz-use-text-color #aaaaaa;
  border-width: 0 0 1px;
  width: 80%;
}
.footer {
  text-align: center;
  padding-top: 30px;
  font-style: italic;
}

  </style></head><body><img style="border: 0pt none ; position: absolute; top: 0pt; right: 0pt;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" alt="Fork me on GitHub" />
<div id="container">
<h1><small>More Info</small><span class="small" /></h1>
<div class="description">Traffic Control Daemon</div>
There are two components to TCD, the daemon and the tools to query the
data collected.<br />
<br />
The daemon polls for statistics, and triggers the associated routines
when the user-defined conditions are met.<br />
The tools are used to find out usage for a given interface.<br />
<br />
TCD was designed from the beginning to be run from a machine that was
not the gateway.&nbsp; It is intended to be run such that the daemon
and tools can reside anywhere on the network that can communicate with
the gateway machine(s) that you want to monitor and control.<br />

<br />
TCDs configuration is done with profiles, and with rules, in
lib/tcd/profiles/ and lib/tcd/rules/ directories respectively.&nbsp;
<br />
<br />
<big style="font-weight: bold;"><big><big>Profiles</big></big></big> define, in <a href="http://en.wikipedia.org/wiki/Ruby_%28programming_language%29">Ruby</a>
syntax, several key methods.<br />
<br />
<div style="margin-left: 40px;">useProfile?()<br />
<div style="margin-left: 40px;">return <span style="font-weight: bold;">true
</span>if this profile is to be used.<br />Use this method to control
when polling is done for the interfaces in
this profile.&nbsp; useProfile?() is called every time the daemon polls
for interfaces, before actually polling this profile.&nbsp; If
useProfile?() returns true, the interface will be polled for
statistics, otherwise it will not.<br />

</div>
getStats()<br />
<div style="margin-left: 40px;">return a Ruby hash in the format of<br />
<div style="margin-left: 40px;">
<pre><big><span class="p">{</span><span class="ss">:eth0</span><span class="o">=&gt;</span>   <span class="p">{</span><span class="ss">:in</span><span class="o">=&gt;</span> 0<span class="p">,</span> <span class="ss">:out</span><span class="o">=&gt;</span> 0<span class="n"><span class="p">}</span> <span class="p">}</span></span></big></pre>

</div>
getStats must return the total number of bytes that have gone in and
out since the last call, and expects each call to zero the counters as
well.&nbsp; This is done instead of trying to track integer
overflow.&nbsp; Multiple interfaces are acceptable as multiple items in
the hash following the above example.<br />
getStats() is the method called to poll for interface statistics after useProfile?() returns true when the daemon polls.<br />
</div>
rolloverDay()<br />
<div style="margin-left: 40px;">return a hash in the format of<br />
<div style="margin-left: 40px;">
<pre><big><span class="p">{</span><span class="ss">:eth0</span><span class="o">=&gt;</span><span class="mi">11</span><span class="p">}</span></big></pre>

</div>
Each interface returned from getStats() must also have a rollover day
defined in this hash.<br />
</div>
maxCapacity()<br />
<div style="margin-left: 40px;">return a hash just as above in the
format of<br />
<div style="margin-left: 40px;">
<pre><big><span class="c1">#60GB =&gt; Bytes == 64 424 509 440</span><span class="p"><span style="font-family: monospace;"><br /><span class="p">{</span><span class="ss">:eth0</span><span class="o">=&gt;</span><span class="mi">64424509440</span><span class="p">}</span></span></span></big><br /></pre>

</div>Where, in that example, the maximum capacity of eth0 is 60
gigabytes, you would use 64424509440, the number of bytes in 60
gigabytes.&nbsp; One for each interface returned in the getStats()
return value.<br />

</div>
</div><br />
<big style="font-weight: bold;"><big><big>Rules</big></big></big> are configured by <span style="font-weight: bold;">register</span>ing
sets of rules, as demonstrated in examples below.&nbsp; The rules
themselves are composed pairs of strings, the first string is the
conditional expression that is <a href="http://en.wikipedia.org/wiki/Eval#Ruby">eval</a>'d to determine if the rule's conditions have been met. The first string must return <span style="font-weight: bold;">true</span>
if the conditions are met and you want the second string, the payload
expression, to be processed.&nbsp; If the conditional evaluates to
true, then the payload expression is eval'd.<br />
Registration involves more than just a set of rules, its based on the
interface name you want the rule to be triggered for (or :all for any
interface), and the percent of bandwidth that triggers running of the
rule (or :all for the rule to be processed all the time).<br />
Some examples of rules and their registration;<br />
<br />
<div style="margin-left: 40px;">TCD::Triggers.register( :eth0, 98, ["true", "`ifdown eth0`"] )<br />
</div>
<div style="margin-left: 80px;">This example registers rules to run
when eth0 reaches 98% bandwidth usage.&nbsp; The rules to register are
'true', which of course will eval to true, and "`ifdown eth0`", which
is intended to disable eth0.<br />
</div>
<br />
<div style="margin-left: 40px;">TCD::Triggers.register( :eth0, :all, ["runWithinLast(15)", "logBandwidthUsed() &amp;&amp; hasRun()"]<br />
</div>
<div style="margin-left: 80px;">This example registers rules to run
every time the daemon processes rules. This is done using :all instead
of using an integer as the second argument.&nbsp; The rules in this
example call the method runWithinLast(15), which the user must
predefine, which presumably returns true if hasRun() has been executed
within the last 15 minutes.&nbsp; The payload expression in this
example is "logBandwidthUsed() &amp;&amp; hasRun()", which presumably
(again the user must predefine these methods) will log your current
bandwidth usage, and makes note that it has run with hasRun().<br />
</div>
<br />
<div style="margin-left: 40px;">TCD::Triggers.register( :all, 98, ["true", "`ifdown #{interface}`"] )<br />
<div style="margin-left: 40px;">This example shows how to register
rules for any interface that reaches 98% bandwidth usage, but it also
demonstrtates the use of the #{interface} expression.&nbsp; The
#{interface} expression is actually just Ruby syntax for interpreting
the value of&nbsp; the variable 'interface' in the string being
evaluated.&nbsp; TCD processes the list of interfaces sequentially,
selecting one with the first argument to register() will cause the
trigger to only continue to be processed for that specified interface.
Using :all for the first argument causes processing to continue up to
the second argument for each interface storing the name of the current
interface in the 'interface' variable.<br />
<br />
What this does is say any interface that reaches 98 percent usage should be disabled.<br />
</div>
</div>

<br />
<div class="footer"> get the source code on GitHub : <a href="http://github.com/jeffWelling/tcd">jeffWelling/tcd</a> </div>
</div>


<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>

<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-11094370-5");
pageTracker._trackPageview();
} catch(err) {}</script></body></html>